# INF6200 – Rapport d’analyse statique

## Table des matières

1. [Présentation](#1-présentation)
2. [Analyseurs étudiés](#2-analyseurs-étudiés)
3. [Analyseurs testés et méthodologie](#3-analyseurs-testés-et-méthodologie)
4. [Résultats sur les tests locaux](#4-résultats-sur-les-tests-locaux)
   - [4.1 Résultats avec Frama-C](#41-résultats-avec-frama-c)
   - [4.2 Résultats avec Clang](#42-résultats-avec-clang)
5. [Analyse d’applications réelles](#5-analyse-dapplications-réelles)
   - [5.1 Frama-c](#51-frama-c)
   - [5.2 Infer](#52-infer)
   - [5.3 Clang](#52-clang)
6. [Tentatives d’analyse avec d'autres outils](#6-tentatives-danalyse-avec-dautres-outils)
   - [6.1 Goblint](#61-goblint)
   - [6.2 Infer](#62-infer)
7. [Conclusion](#7-conclusion)
8. [Documentation](#8-documentation)

---

Supervised by Quentin Stievenar (https://qstievenart.gitlab.io/)

## 1. Présentation

Ce projet a été réalisé dans le cadre du cours **INF6200** durant la session d'été 2025, sous la supervision du professeur **Quentin Stiévenart**. L’objectif est de comparer différents **analyseurs statiques** afin de détecter des **vulnérabilités**, en particulier les **buffer overflows**, sur des fichiers tests ainsi que sur des projets open-source comme **Coreutils** et **BusyBox**.

---

## 2. Analyseurs étudiés

| Analyseur              | Description |
|------------------------|-------------|
| **Clang Static Analyzer** | Intégré à LLVM. Bon pour les accès mémoire hors limites. |
| **IKOS**               | Développé par la NASA. Basé sur l’interprétation abstraite. |
| **Goblint**            | Spécialisé dans les bugs de concurrence et les buffers. |
| **Infer**              | Créé par Meta. Bonne échelle, peu de faux positifs. |
| **Cppcheck**           | Open-source, simple et efficace. |
| **Sparrow**            | Analyse poussée des pointeurs. Bon compromis précision/performance. |
| **Frama-C**            | Plateforme d’analyse statique avancée pour le C, basée sur l’interprétation abstraite. Très précise pour la détection des erreurs mémoire comme les buffer overflows. |

---

## 3. Analyseurs testés et méthodologie

Nous avons testé les outils suivants :

- **Frama-C**
- **Clang**
- **Goblint**
- **Infer**

### Méthodologie

L’analyse a été menée en deux étapes :

1. **Tests sur des fichiers personnalisés** :
   Afin de bien comprendre le fonctionnement de chaque outil et éviter les problèmes liés à l’inclusion de fichiers d’en-tête externes (souvent rencontrés dans les suites de tests Juliet), nous avons d’abord rédigé **nos propres fichiers de test** contenant volontairement des erreurs de type **buffer overflow**.

2. **Tests sur des applications réelles** :
   Par la suite, nous avons appliqué les mêmes outils sur des programmes issus d’applications réelles mentionnées dans [cette publication](https://yuleisui.github.io/publications/icse24a.pdf), notamment **Coreutils**, **BusyBox**, **tmux** et **darknet**, afin d’évaluer leurs performances dans un contexte plus complexe et réaliste.

Nous avons essayé avec les tests juliet mais on a eu plein de problème de d'inclusion de fichier d'en-tête donc on décide d'utiliser nos propres fichiers tests
ce qui nous a conduit a tester Frama-C sur les 7 fichiers tests qu'on a nous même créer pour éviter des soucis d'inclusion. 

---
## 4. Résultats des analyses sur les tests locaux

### 4.1 Résultats avec Frama-C

frama-c détecte bien les buffer_overflows des différent fichiers tests qu'on a créer, il s'agit de petit programme contenant un buffer_overflow chacun.

Lorsqu'on lance l'analyse sur le fichier [test1_strcpy_overflow](Tests/test1_strcpy_overflow.c) avec la commande `frama-c -eva Tests/test1_strcpy_overflow.c`, on obtient le résultat suivant 

```frama-c -eva Tests/test1_strcpy_overflow.c 
[kernel] Parsing Tests/test1_strcpy_overflow.c (with preprocessing)
[eva] Analyzing a complete application starting at main
[eva:initial-state] Values of globals at initialization
  
[eva] using specification for function strcpy
[eva:alarm] Tests/test1_strcpy_overflow.c:7: Warning: 
  function strcpy: precondition 'room_string' got status invalid.
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function main:
  NON TERMINATING FUNCTION
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  1 function analyzed (out of 1): 100% coverage.
  In this function, 2 statements reached (out of 5): 40% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  0 alarms generated by the analysis.
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     2 valid     0 unknown     1 invalid      3 total
  66% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
```

Elle a détecté une erreur dans l’appel à strcpy, comme prévu. Le message `"room_string" got status invalid` signifie que frama-c a analysé que le buffer (de taille 10) est trop petit pour contenir "Cette chaîne est trop longue pour le buffer" (longueur > 40). et le message `NON TERMINATING FUNCTION` est lié à un comportement indéfini causé par le buffer overflow (Frama-C s'arrête là).

Lorsqu'on lance l'analyse sur le fichier [test5_stack_buffer_overflow](Tests/test5_stack_buffer_overflow.c) avec la commande `frama-c -eva Tests/test5_stack_buffer_overflow.c`, on obtient le résultat suivant 

```
frama-c -eva Tests/test5_stack_buffer_overflow.c 
[kernel] Parsing Tests/test5_stack_buffer_overflow.c (with preprocessing)
[eva] Analyzing a complete application starting at main
[eva:initial-state] Values of globals at initialization
  
[eva] using specification for function strcpy
[eva:alarm] Tests/test5_stack_buffer_overflow.c:7: Warning: 
  function strcpy: precondition 'room_string' got status invalid.
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function main:
  NON TERMINATING FUNCTION
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  1 function analyzed (out of 1): 100% coverage.
  In this function, 2 statements reached (out of 5): 40% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  0 alarms generated by the analysis.
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     2 valid     0 unknown     1 invalid      3 total
  66% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
```

Encore une fois, frama-c fait bien son travail ici, il détecte un buffer overflow potentiel dans le fichier. `function strcpy: precondition 'room_string' got status invalid.` cela signifie que Frama-C ne peut pas garantir que local_buffer a assez de place pour contenir la chaîne input et c’est exact : le buffer fait 8 octets, et on essaye de copier une chaîne de 24 caractères — overflow assuré.

Pour l'analyse des autres codes les resultat seront dans le tableau ci-dessous.

| Test          | Resultat      | Détail           |
|---------------|---------------|------------------|
| Test2         | Oui           | [ici](resultats/res_test2.md) |
| Test3         | Non           | [ici](resultats/res_test3.md) |
| Test4         | Oui           | [ici](resultats/res_test4.md) |
| Test6         | Oui           | [ici](resultats/res_test6.md) |
| Test7         | Oui           | [ici](resultats/res_test7.md) |

Dans le résultat du Test3, Frama-C nous donne des warnings de précondition mais ne détecte pas de buffer overflow comme dans les autres programmes.

Dans les deux résultats ci-haut on a ce message `In this function, 2 statements reached (out of 5): 40% coverage.`.

Cela signifie que Frama-C a seulement analysé 2 instructions sur les 5 présentes dans la fonction main. Ce faible taux de couverture s’explique par le fait que Frama-C s’arrête dès qu’il rencontre une erreur critique, comme une violation de précondition, ici causée par un buffer overflow avec strcpy.

Plus précisément, lors de l’analyse, Frama-C évalue toutes les exécutions possibles du programme. Si une de ces exécutions mène à un comportement non défini, par exemple une écriture hors des limites d’un tableau, l’analyse s’arrête à ce point précis, sans poursuivre le flot de contrôle. Cela a pour conséquence que les lignes de code suivantes ne sont pas explorées, d’où le faible pourcentage de couverture.

Dans le cas de programme plus volumineux frama-c détectera les vulnérabilités un par un car à chaque fois qu'il va trouver une erreurs il n'analysera pas la suite du code tant que ce dernier n'est pas réglé,Mais ce n’est pas une faiblesse :  ce qui est le principe même de l'analyse statique.

### 4.2 Résultats avec Clang

Étant donnée que l'analyse avec frama-c à porter ses fruits alors nous avons décidé d'essayer d'autre analyseur pour faire une comparaison entre les résultats des différentes analyses.

#### Commande utilisée

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test1_strcpy_overflow.c
```

#### Résultat obtenu

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test1_strcpy_overflow.c
Tests/test1_strcpy_overflow.c:7:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
    7 |     strcpy(buffer, source);  // BUFFER OVERFLOW
      |     ^~~~~~
1 warning generated.
```

#### Interprétation :

Clang détecte l’utilisation de la fonction strcpy, considérée comme non sécurisée car elle ne vérifie pas les limites du tampon de destination. Il émet une alerte de type CWE-119, ce qui concorde parfaitement avec les résultats de Frama-C, qui signale un débordement de tampon lors de l’analyse.

#### Commande utilisée

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test2_strcat_overflow.c
```

#### Résultat obtenu

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test2_strcat_overflow.c 
Tests/test2_strcat_overflow.c:7:5: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [security.insecureAPI.strcpy]
    7 |     strcat(buffer, append);  // BUFFER OVERFLOW
      |     ^~~~~~
1 warning generated.
```

#### Interprétation :

Clang identifie ici encore une fonction dangereuse (strcat), qui concatène des chaînes sans vérification de taille. L'avertissement est pertinent et cohérent avec l’analyse de Frama-C, qui détecte un risque de débordement de tampon à l'exécution.

#### Commande utilisée

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test4_sprintf_overflow.c
```

#### Résultat obtenu

```
yaya@yaya-Inspiron-15-5518:~/Documents/COURS_UQAM/INF6200/inf6200$ clang --analyze -Xanalyzer -analyzer-checker=security Tests/test4_sprintf_overflow.c 
Tests/test4_sprintf_overflow.c:7:5: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    7 |     sprintf(buffer, "Résultat: %d - %s - Extra", number, text);  // OVERFLOW
      |     ^~~~~~~
1 warning generated.
```

#### Interprétation :

Clang met en garde contre `sprintf`, une fonction connue pour être vulnérable aux débordements si mal utilisée. Il suggère l’usage de `snprintf` ou `sprintf_s`. Cette détection est pertinente même si le débordement exact n’est pas analysé, car le format utilisé dépasse potentiellement la taille du tampon.

#### Commande utilisée

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test5_stack_buffer_overflow.c
```

#### Résultat obtenu

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test5_stack_buffer_overflow.c 
Tests/test5_stack_buffer_overflow.c:7:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
    7 |     strcpy(local_buffer, input);  // OVERFLOW
      |     ^~~~~~
1 warning generated.
```

#### Interprétation :

Clang détecte ici un cas similaire à test1, avec un dépassement de pile causé par l’utilisation de strcpy sur un tampon local trop petit. L’analyse ne détecte pas explicitement l’overflow effectif, mais met en garde contre l’usage de l’API, ce qui est en accord avec les résultats de Frama-C.

#### Commande utilisée

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test6_secure_strncpy.c
```

#### Résultat obtenu

```
clang --analyze -Xanalyzer -analyzer-checker=security Tests/test6_secure_strncpy.c 
Tests/test6_secure_strncpy.c:12:5: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   12 |     strncpy(buffer, source, sizeof(buffer) - 1);
      |     ^~~~~~~
1 warning generated.
```

#### Interprétation :

Clang ne signale pas ici un débordement, mais mentionne que strncpy est dépréciée ou considérée obsolète par rapport aux normes C11. L’appel à strncpy est correct sur le plan de la taille (grâce au sizeof(buffer) - 1), mais Clang recommande malgré tout des alternatives comme strncpy_s.

Par contre, lors de l’analyse des programmes test3_gets_overflow.c et test7_loop_off_by_one.c, Clang ne détecte aucune vulnérabilité, comme le montrent les résultats suivants :

`clang --analyze -Xanalyzer -analyzer-checker=security Tests/test3_gets_overflow.c`

Aucun avertissement n’est généré.

Ce résultat est attendu car le programme utilise fgets() avec une taille de tampon correctement spécifiée (sizeof(buffer)), ce qui évite le dépassement de mémoire. De plus, la fonction gets(), qui est réellement dangereuse, est commentée dans le code. Clang n’émet donc aucun avertissement dans ce cas.

`clang --analyze -Xanalyzer -analyzer-checker=security Tests/test7_loop_off_by_one.c`

Aucun avertissement n’est généré.

Ce résultat peut sembler surprenant, car le programme contient une erreur de dépassement de tableau de type off-by-one (la boucle for (int i = 0; i <= 10; i++) écrit jusqu’à buffer[10], alors que buffer a une taille de 10). Cependant, Clang ne détecte pas ce type d’erreur logique car :

L’analyse statique de Clang ne suit pas en détail les valeurs des indices de boucle.

Il se concentre principalement sur l’utilisation d’APIs dangereuses connues (comme strcpy, strcat, gets, etc.).

Les dépassements de tableau causés par des erreurs de logique (<= au lieu de <) ne sont pas traités comme des vulnérabilités explicites par le checker security.

Cela constitue une limite de Clang dans le contexte de la détection des erreurs mémoire subtiles, notamment celles issues de boucles mal formées.

## 5. Analyse d'applications réelles

### 5.1 Frama-C

#### 5.1.1 Analyse de Busybox

#### Objectif
Analyser un fichier C de l'application Busybox (coreutils/basename.c) avec Frama-C.

#### Premier essai - Problèmes rencontrés

**Commande exécutée :**

`frama-c -eva coreutils/basename.c`

**Problème :** Fichier manquant `libbb.h`

```bash
fatal error: libbb.h: Aucun fichier ou dossier de ce nom
  46 | #include "libbb.h"
     |          ^~~~~~~~~
compilation terminated.
```

#### Configuration manuelle de Busybox

**Étapes pour générer les headers :**
## Générer les headers (include/autoconf.h)

`make defconfig`

## Compiler pour que les headers soient en place
`make`

**Résultat :** [Erreurs de compilation](busybox/erreur_make_busybox.md)
- Erreurs dues à des structures et constantes non définies (`TCA_CBQ_MAX, struct tc_cbq_lssopt`, etc.)

#### Solution alternative : Analyse avec Clang

**1. Configuration sélective de Busybox :**

```bash
make defconfig
make menuconfig
```

- Désactiver `tc` dans Networking Utilities
- Garder seulement les programmes simples (true, false, echo, cat)

**2. Compilation avec Clang :**

`make CC=clang`

**3. Génération d'un fichier prétraité (.i) :**

`clang -E -Iinclude -I. -include include/autoconf.h coreutils/true.c -o true.i`

**4. Analyse avec Frama-C :**

`frama-c -cpp-extra-args="-Iinclude -I." true.i`

**Résultat :** [Sortie très verbeuse](busybox/resultat_busybox.md) avec de nombreux warnings difficiles à interpréter.

#### Analyse avec programmes réécrits

**Approche :** Réécriture des programmes en remplaçant les `#include` par du code direct.
- Exemple : [cat.c réécrit](busybox/my_includes/cat.c)

**Commande :**

`frama-c -eva -main cat_main busybox/my_includes/cat.c`

**Résultat :**

```bash
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function cat_main:
 argv ∈ {{ &S_argv{[0], [1]} }}
 opts ∈ {0}
 __retres ∈ {0}

[eva:summary] ====== ANALYSIS SUMMARY ======
 3 functions analyzed (out of 11): 27% coverage.
 16 statements reached (out of 23): 69% coverage.
 1 alarm generated: 1 invalid memory access
```

## 5.2 Infer

#### 5.2.1 Analyse de Darknet

**Première tentative :**

`infer run -- gcc -c src/compare.c`

**Problème :** Erreur d'inclusion `darknet.h`

**Solution - Commande finale :**

`infer run -- gcc -c -I./include -I./src -I./lib src/compare.c`

**Correction nécessaire dans compare.c :**
- Remplacer `network net = ...` par `network *net = ...`
- Remplacer les accès `.` par `->` pour les pointeurs

**Résultat :**

```bash
src/compare.c:121: error: Dead Store
 The value written to `&num` is never used.
 121. num = (i+1)*N/splits - i*N/splits;
```

**Analyse étendue :**

`infer run -- gcc -c -I./include -I./src -I./lib src/*.c`

**Résultats complets :** [report.txt](darknet/infer-out/report.txt)
- Aucun buffer overflow détecté
- Quelques avertissements Dead Store et problèmes mineurs

#### 5.2.2 Analyse de Busybox

**Commande :**

`infer run -- gcc -c ../Documents/COURS_UQAM/INF6200/inf6200/busybox/coreutils/cat.c`

**Résultat :** [Voir résultats](resultat_infer.md)

**Analyse avec programmes réécrits :**

`infer run -- gcc -c ../Documents/COURS_UQAM/INF6200/inf6200/busybox/my_includes/cat.c`

**Résultat :**
```bash
No issues found
```

### 5.3 Clang Static Analyzer

#### 5.3.1 Analyse de Darknet

**Commande :**

`clang --analyze -I./include -I./src -I./lib src/*.c`

**Résultats :** [Rapport complet](darknet/repport.txt)

**Types de problèmes détectés :**
- Mauvaise utilisation de `calloc` avec la taille
- Variables assignées mais jamais lues (Dead Stores)  
- Fuites potentielles de mémoire (malloc/calloc sans free)
- Passage de pointeurs NULL à des fonctions qui attendent des pointeurs non NULL

### 5.4 Goblint

#### 5.4.1 Analyse de Busybox

**Commande :**

`goblint -I include coreutils/cat.c`

**Résultat :**

```bash
include/libbb.h[1552:5-36] : syntax error
Parsing errorFatal error: exception Goblint_lib__Maingoblint.FrontendError("Frontc.ParseError: Parse error")
```

**Problème :** Erreur de syntaxe dans `include/libbb.h` à la ligne 1552.

## 7. Conclusion

### Ce qui s’est bien passé

* Les analyses statiques de **Darknet** avec **Infer** et **Clang** se sont déroulées sans crash.
* **Frama-c**, **Infer** et **Clang**  se sont avérés hyper éfficace sur les petits programmes
* Aucun **buffer overflow**  n’a été détecté dans les fichiers analysés.
* L’outil a signalé uniquement des **warnings** mineurs (ex. : types incompatibles, fonctions sans prototype, risque de fuite de mémoire).
* L’approche multi-outils (Infer, Clang, Frama-C, Goblint) a permis de **diversifier la couverture des analyses**.

### Ce qui s’est mal passé / Limites rencontrées

* **Frama-C** a échoué sur les applications qui ont une ou plusieurs inclusions de fichier (**darknet**, **tests juliets**, etc).
* Certains outils comme **Goblint** nécessitent une configuration complexe ou des restrictions (ex: code séquentiel).
* L’**intégration avec des projets complexes** comme BusyBox ou Darknet demande un effort d’adaptation (includes, flags de compilation).
* Difficile de trouver des applications réelles aves des **buffer overflows.**

### Étapes suivantes possibles

1. **Adapter Frama-C à l'analyse complète** : remplacer les directives OpenMP par du code séquentiel temporairement ou utiliser `-cpp-extra-args="-fopenmp"` si supporté.
2. **Analyser une portion ciblée de Darknet** (ex. : couche `convolutional_layer.c`) avec Frama-C en ajoutant des annotations ACSL.
3. **Configurer Goblint** pour analyser de petites fonctions isolées (issues de Juliet ou du projet).
4. **Créer un pipeline automatisé** (Makefile ou script Python) qui lance les outils avec configuration adaptée.
5. **Comparer les outils sur les tests Juliet**, mesurer : nombre de vulnérabilités détectées, précision, temps d’analyse, taux de faux positifs.

---

### Bilan

Ce projet a permis de mettre en œuvre une **analyse statique multi-outils sur un projet réel**, de bien cerner les **forces et faiblesses des analyseurs**, et d’identifier des pistes d’amélioration pour **approfondir l’évaluation de la sécurité logicielle** dans des systèmes complexes comme ceux utilisés en IA ou en embarqué.



## 8. Documentation

### Applications testées

| Application     | Description                                                                 | Lien du dépôt                                                                 |
|-----------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| **Darknet**     | Réseau de neurones convolutifs utilisé pour la détection d’objets (YOLO).  | [https://github.com/pjreddie/darknet](https://github.com/pjreddie/darknet)  |
| **BusyBox**     | Suite d’utilitaires UNIX combinés dans un seul binaire, utilisée en embarqué. | [https://git.busybox.net/busybox/](https://git.busybox.net/busybox/) <br> [Miroir GitHub](https://github.com/mirror/busybox) |
| **Juliet Test Suite** | Corpus de programmes C/C++ vulnérables pour l’évaluation d’outils d’analyse statique. | [https://samate.nist.gov/SRD/testsuite.php](https://samate.nist.gov/SRD/testsuite.php) |

---

### Outils d’analyse utilisés

| Outil             | Description                                                                 | Lien                                                                            |
|-------------------|-----------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| **Infer**         | Analyse statique développée par Meta (Facebook), détecte fuite mémoire, overflow, etc. | [https://fbinfer.com](https://fbinfer.com) <br> [https://github.com/facebook/infer](https://github.com/facebook/infer) |
| **Frama-C**       | Plateforme d’analyse statique formelle pour le langage C.                   | [https://frama-c.com](https://frama-c.com) <br> [https://git.frama-c.com/pub/frama-c](https://git.frama-c.com/pub/frama-c) |
| **Clang Static Analyzer** | Analyse statique via `scan-build`, intégré à LLVM.                          | [https://clang-analyzer.llvm.org](https://clang-analyzer.llvm.org)             |
| **Goblint**       | Analyse statique interprocédurale pour C, spécialisée en analyse concurrente. | [https://github.com/goblint/analyzer](https://github.com/goblint/analyzer)     |

---
